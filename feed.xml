

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>/</id>
  <title>Lil Martin</title>
  <subtitle>一个菜鸡全栈程序员博主。</subtitle>
  <updated>2021-11-07T22:34:41+08:00</updated>
  <author>
    <name>Martin_Du</name>
    <uri>/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en-US"
    href="/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Martin_Du </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>React Axios(请求)</title>
    <link href="/posts/React-Axios/" rel="alternate" type="text/html" title="React Axios(请求)" />
    <published>2021-10-15T10:22:00+08:00</published>
  
    <updated>2021-10-15T10:22:00+08:00</updated>
  
    <id>/posts/React-Axios/</id>
    <content src="/posts/React-Axios/" />
    <author>
      <name>Martin_Du</name>
    </author>

  
    
    <category term="react" />
    
    <category term="react-Advanced-Component" />
    
  

  
    <summary>
      





      React-Axios基本使用



Axios 安装

  
    进入之前创建的脚手架app中执行以下两个命令中的其中一个

    $ npm install react-axios
$ yarn add axios
    
  


Axios Get请求

//为给定 ID 的 User 创建请求
axios.get(
	'url',
    paras:{
    	para1: value1,
    	...
    }
).then((res) =&amp;gt; {
    //成功后执行此处代码块
  	console.log(res);
}).catch((err) =&amp;gt; {
    //失败则执行此处代码块
    console.log(err);
});
//也可以直接用?para1=value将其接在url后面


Axios Post请求

axi...
    </summary>
  

  </entry>

  
  <entry>
    <title>React Router(路由)</title>
    <link href="/posts/React-Router/" rel="alternate" type="text/html" title="React Router(路由)" />
    <published>2021-10-12T23:28:00+08:00</published>
  
    <updated>2021-10-12T23:28:00+08:00</updated>
  
    <id>/posts/React-Router/</id>
    <content src="/posts/React-Router/" />
    <author>
      <name>Martin_Du</name>
    </author>

  
    
    <category term="react" />
    
    <category term="react-Advanced-Component" />
    
  

  
    <summary>
      





      简介



官方简介


  React Router 是一个基于 React 之上的强大路由库，它可以让你向应用中快速地添加视图和数据流，同时保持页面与 URL 间的同步。


个人理解

  也就是将这个”网页”/”网站”，变得更加组件化，使元素树结构更加直观。


安装

  
    以下二选一

    $ npm install --save react-router-dom
$ yarn add react-router-dom
    
  


内置包



import { Link, NavLink, Switch, Route, BrowserRouter } from 'react-router-dom'


Link | NavLink

  
    作用与 a 标签类似:

    将网页地址渲染为 “目标地址”(最终会被渲染为a元素)

    
 ...
    </summary>
  

  </entry>

  
  <entry>
    <title>Orcale基础(七)视图、索引、事务</title>
    <link href="/posts/Oracle-view/" rel="alternate" type="text/html" title="Orcale基础(七)视图、索引、事务" />
    <published>2021-10-11T16:33:00+08:00</published>
  
    <updated>2021-10-11T16:33:00+08:00</updated>
  
    <id>/posts/Oracle-view/</id>
    <content src="/posts/Oracle-view/" />
    <author>
      <name>Martin_Du</name>
    </author>

  
    
    <category term="sql" />
    
    <category term="oracle" />
    
  

  
    <summary>
      





      视图(view)



作用


  控制数据访问
  简化查询
  数据独立性
  避免重复访问相同的数据


视图的创建

注意

在运维数据库，对一些数据进行操作时，最好先将要操作的数据备份，然后再操作数据或者直接操作备份后的数据。

-- 快速复制表结构，如果复制的表有数据，则顺势复制表中的所有数据。
create table emp_bank
	as 
	select * from emp


创建方法

-- `create or replace` 表示如果创建的视图已存在则替换
create or replace view v_emp_bank
	as select ename, sal 
		from emp_bank


创建之后可以直接通过 select 查询该视图的结果


  该结果与 as 后的 select 结果相同。


view 的好处

例1

查询...
    </summary>
  

  </entry>

  
  <entry>
    <title>Orcale基础(六)rownum与主键设计</title>
    <link href="/posts/Oracle-rownum-pk/" rel="alternate" type="text/html" title="Orcale基础(六)rownum与主键设计" />
    <published>2021-10-11T11:28:00+08:00</published>
  
    <updated>2021-10-11T11:28:00+08:00</updated>
  
    <id>/posts/Oracle-rownum-pk/</id>
    <content src="/posts/Oracle-rownum-pk/" />
    <author>
      <name>Martin_Du</name>
    </author>

  
    
    <category term="sql" />
    
    <category term="oracle" />
    
  

  
    <summary>
      





      主键设计

ROWNUM 和 ROWID

ROWID

特点：唯一，且固定，是在行数据生成时产生的id；

select rowid, empno from emp;
-- 此时的查询结果中，所有行的rowid字段是唯一的
select rowid, empno from emp where empno = 7369;
-- 该结果中
-- empno=7369的rowid 和 
-- 上一条 select 语句结果中empno=7369的rowid 相同



  ROWID是永远不变的， 永远跟行记录走，不因查询条件而变化


ROWNUM

特点：一个伪列，对查询结果返回的行编号即行号，由1开始 依次递增

-- 返回该表全部14条数据
select rownum, emp.* from emp; -- 结果的rownum为1-14
-- 返回部门号为30的6条数据
sele...
    </summary>
  

  </entry>

  
  <entry>
    <title>Orcale基础(五)子查询</title>
    <link href="/posts/Oracle-ChildQuery/" rel="alternate" type="text/html" title="Orcale基础(五)子查询" />
    <published>2021-10-09T23:00:00+08:00</published>
  
    <updated>2021-10-09T23:00:00+08:00</updated>
  
    <id>/posts/Oracle-ChildQuery/</id>
    <content src="/posts/Oracle-ChildQuery/" />
    <author>
      <name>Martin_Du</name>
    </author>

  
    
    <category term="sql" />
    
    <category term="oracle" />
    
  

  
    <summary>
      





      子查询

分为 关联子查询 和 非关联子查询

特点：子查询可以单独执行，其结果作为外部查询的条件。

不相关子查询

概念：子查询不需要与父查询的结果进行比对

-- 查询各个部门薪水最高的员工信息
select * from emp
	where (deptno, sal) in
	(
    	select deptno, max(sal) from emp group by deptno
    )
-- 哪些部门没有员工
select * from dept
	where deptno not in
	(
    	select deptno from emp group by deptno
    )



  整个过程中，父查询的值没有进入子查询


普通 where 条件 子查询

-- 查询所有工资高于FORD的员工信息
select empno,ename,job...
    </summary>
  

  </entry>

</feed>


