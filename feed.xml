

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>/</id>
  <title>Lil Martin</title>
  <subtitle>一个爱学习的菜鸟程序员。</subtitle>
  <updated>2022-03-31T15:53:04+08:00</updated>
  <author>
    <name>Martin_Du</name>
    <uri>/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en-US"
    href="/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2022 Martin_Du </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>Hibernate</title>
    <link href="/posts/Hibernate/" rel="alternate" type="text/html" title="Hibernate" />
    <published>2022-03-24T00:00:00+08:00</published>
  
    <updated>2022-03-24T00:00:00+08:00</updated>
  
    <id>/posts/Hibernate/</id>
    <content src="/posts/Hibernate/" />
    <author>
      <name>Martin_Du</name>
    </author>

  
    
  

  
    <summary>
      





      Hibernate

Hibernate简介

ORM(Object Relation Mapping)


  译为：对象关系映射，解决了对象和关系型数据库之间得数据交互问题。


ORM技术可以根据提前配置好得对象和数据库之间的映射关系生成对应的SQL语句，整个过程不需要人工干预。


  
    
      数据库
      类/对象
    
  
  
    
      表（table）
      类（class）
    
    
      表中的记录（record，也称行）
      对象（Object）
    
    
      表中的字段（field，也称列）
      对象中的属性（attribute）
    
  


ORM框架

ORM 技术通常使用单独的框架，或者框架的某个模块来实现，下面列出了常用的 ORM 框架：


  常...
    </summary>
  

  </entry>

  
  <entry>
    <title>JavaWeb基础——servlet</title>
    <link href="/posts/Servlet/" rel="alternate" type="text/html" title="JavaWeb基础——servlet" />
    <published>2022-03-06T22:22:22+08:00</published>
  
    <updated>2022-03-06T22:22:22+08:00</updated>
  
    <id>/posts/Servlet/</id>
    <content src="/posts/Servlet/" />
    <author>
      <name>Martin_Du</name>
    </author>

  
    
    <category term="java" />
    
    <category term="javaweb" />
    
  

  
    <summary>
      





      概述

简单点说，关于JavaWeb基础，也就是Servlet、JSP 以及 MVC 模式编程。

Servlet

一个继承了HttpServlet 的 Java 类，可用于接收网络中的请求并做一些处理。

目前常用的类长这样：

public class Servlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException{
        doGet(request, response);
    }
    
    protected void doGet(HttpServletRequest request, HttpServletRespon...
    </summary>
  

  </entry>

  
  <entry>
    <title>算法篇：全排列(eg:蓝桥杯 ALGO-1005 数字游戏)</title>
    <link href="/posts/AL-Search/" rel="alternate" type="text/html" title="算法篇：全排列(eg:蓝桥杯 ALGO-1005 数字游戏)" />
    <published>2022-01-24T10:00:00+08:00</published>
  
    <updated>2022-01-25T00:22:14+08:00</updated>
  
    <id>/posts/AL-Search/</id>
    <content src="/posts/AL-Search/" />
    <author>
      <name>Martin_Du</name>
    </author>

  
    
    <category term="java" />
    
    <category term="Algorithm" />
    
  

  
    <summary>
      





      全排列

顾名思义：就是将所有元素按照一定顺序排列一遍。


  例如：现在有一组数组[1,2,3]

  这个数组全排列的结果就是 { [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] }

  这么说就懂了吧！


那么如何用 编程 解决呢？

说到排列，那么最常用的自然是递归！

那么问题又来了，怎么 “递”？

咱先来个思维导图（以下图中的数组为例）



一般对某一个数组进行排列的顺序是从后往前，将前面的部分固定，对后面的序列子集进行排列。



此时就需要划分 一条 分割线，说是一条，实际上每个元素的左侧都有一条分割线，但这条“分割线”只能向右移动，移动到最右侧后失效。

最外层分割线的划分是从右往左的，当划分了最外层分割先后，右侧的分割线均视为子集分割线。

如下图：



第一次排列：即按字典序（由小到大）排列。...
    </summary>
  

  </entry>

  
  <entry>
    <title>@vueRouter3.x Basic</title>
    <link href="/posts/Vue-Router/" rel="alternate" type="text/html" title="@vueRouter3.x Basic" />
    <published>2021-12-22T09:43:20+08:00</published>
  
    <updated>2021-12-22T09:43:20+08:00</updated>
  
    <id>/posts/Vue-Router/</id>
    <content src="/posts/Vue-Router/" />
    <author>
      <name>Martin_Du</name>
    </author>

  
    
    <category term="vue" />
    
    <category term="vue-router" />
    
  

  
    <summary>
      





      基础

安装请看官方文档router-vue

基础路由匹配

html

&amp;lt;script src="https://unpkg.com/vue/dist/vue.js"&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src="https://unpkg.com/vue-router/dist/vue-router.js"&amp;gt;&amp;lt;/script&amp;gt;

&amp;lt;div id="app"&amp;gt;
  &amp;lt;h1&amp;gt;Hello App!&amp;lt;/h1&amp;gt;
  &amp;lt;p&amp;gt;
    &amp;lt;!-- 使用 router-link 组件来导航. --&amp;gt;
    &amp;lt;!-- 通过传入 `to` 属性指定链接. --&amp;gt;
    &amp;lt;!-- &amp;lt;router-link&amp;gt; 默认会被渲染成一个 `&amp;lt;a&amp;gt;` 标签 --...
    </summary>
  

  </entry>

  
  <entry>
    <title>@vue/cli4.x脚手架使用</title>
    <link href="/posts/Vue-Cli-Review/" rel="alternate" type="text/html" title="@vue/cli4.x脚手架使用" />
    <published>2021-12-20T09:25:20+08:00</published>
  
    <updated>2021-12-20T09:25:20+08:00</updated>
  
    <id>/posts/Vue-Cli-Review/</id>
    <content src="/posts/Vue-Cli-Review/" />
    <author>
      <name>Martin_Du</name>
    </author>

  
    
    <category term="vue" />
    
    <category term="vue-cli" />
    
  

  
    <summary>
      





      脚手架基础知识

安装及创建项目

vue cli官方文档 讲的很清楚

项目结构

目录结构

├── public
│   └── index.html
├── src
|   ├── main.js				# 项目的初始化
|   ├── App.vue				# 项目的入口组件
|	├── assest			 	# 项目中展示的图片或者全局样式
|	│   ├── css
|	│   ├── img
|	│   └── ...
|	├── api
|	│   └── ... 			# 抽取出API请求
|	├── components
|	│   └── ...				# 项目中可复用的组件
|	├── view				# 视图界面组件（我理解的是路由对应的组件
|	│   └── ...				
|	├── store
|	|	├── index.js        # 我...
    </summary>
  

  </entry>

</feed>


