[
  
  {
    "title": "宝塔+Lychee部署自己的图床",
    "url": "/posts/Lychee-CDN/",
    "categories": "linux",
    "tags": "linux",
    "date": "2022-04-01 16:04:00 +0800",
    





    "snippet": "宝塔+Lychee部署一个自己的图床准备工作一台服务器环境：  Linux（Ubuntu、CentOS都可）  PHP 7.x以上版本 *  MySQL 5.x以上版本  Nginx 1.x以上版本软件：Lychee+宝塔步骤安装宝塔面板安装方法网上很多。创建新的站点记得添加数据库，记住账号密码（记不住也没事，可以改）下载Lychee源码  到GitHub官网下载源码压缩包（也可以通过SSH进到目录下通过git clone 克隆源码）Lychee github地址将源码部署到服务器  找到刚刚添加站点时创建的目录，上传并解压压缩包，将文件夹中的所有文件剪切到网站根目录，然后删掉压缩包和源..."
  },
  
  {
    "title": "Spring——基础(持续更新中)",
    "url": "/posts/Spring/",
    "categories": "java, spring",
    "tags": "java, Spring",
    "date": "2022-03-06 22:22:22 +0800",
    





    "snippet": "Spring概述  最受欢迎的企业级 Java 应用程序开发框架  一个开源的 Java 平台  轻量级的框架，基础版本只有2M左右  框架的核心特性是可以用于开发任何 Java 应用程序三层架构  表现层：Web层 MVC是表现层的一个设计模型  业务层：Service层  持久层：dao层特性非侵入式、控制反转（IOC）、依赖注入、面向切面（AOP）、容器、组件化、一站式。。。参考文章：W3Cschool体系结构核心容器  Spring-core：提供了框架的基本组成部分，包括IoC和依赖注入功能。  Spring-beans：模块提供 BeanFactory，应用工厂模式。  co..."
  },
  
  {
    "title": "持久层框架——Hibernate",
    "url": "/posts/Hibernate/",
    "categories": "java, hibernate",
    "tags": "java, hibernate",
    "date": "2022-03-06 22:22:22 +0800",
    





    "snippet": "HibernateHibernate简介ORM(Object Relation Mapping)  译为：对象关系映射，解决了对象和关系型数据库之间得数据交互问题。ORM技术可以根据提前配置好得对象和数据库之间的映射关系生成对应的SQL语句，整个过程不需要人工干预。            数据库      类/对象                  表（table）      类（class）              表中的记录（record，也称行）      对象（Object）              表中的字段（field，也称列）      对象中的属性（attribute..."
  },
  
  {
    "title": "JavaWeb基础——servlet",
    "url": "/posts/Servlet/",
    "categories": "java, javaweb",
    "tags": "java, servlet",
    "date": "2022-03-06 22:22:22 +0800",
    





    "snippet": "概述简单点说，关于JavaWeb基础，也就是Servlet、JSP 以及 MVC 模式编程。Servlet一个继承了HttpServlet 的 Java 类，可用于接收网络中的请求并做一些处理。目前常用的类长这样：public class Servlet extends HttpServlet {    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException{        doGet(request, resp..."
  },
  
  {
    "title": "算法篇：全排列(eg:蓝桥杯 ALGO-1005 数字游戏)",
    "url": "/posts/AL-Search/",
    "categories": "java, Algorithm",
    "tags": "java, list, algorithm",
    "date": "2022-01-24 10:00:00 +0800",
    





    "snippet": "全排列顾名思义：就是将所有元素按照一定顺序排列一遍。  例如：现在有一组数组[1,2,3]  这个数组全排列的结果就是 { [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] }  这么说就懂了吧！那么如何用 编程 解决呢？说到排列，那么最常用的自然是递归！那么问题又来了，怎么 “递”？咱先来个思维导图（以下图中的数组为例）一般对某一个数组进行排列的顺序是从后往前，将前面的部分固定，对后面的序列子集进行排列。此时就需要划分 一条 分割线，说是一条，实际上每个元素的左侧都有一条分割线，但这条“分割线”只能向右移动，移动到最右侧后失效。最..."
  },
  
  {
    "title": "@vueRouter3.x Basic",
    "url": "/posts/Vue-Router/",
    "categories": "vue, vue-router",
    "tags": "vue, javascript",
    "date": "2021-12-22 09:43:20 +0800",
    





    "snippet": "基础安装请看官方文档router-vue基础路由匹配html&amp;lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;div id=&quot;app&quot;&amp;gt;  &amp;lt;h1&amp;gt;Hello..."
  },
  
  {
    "title": "@vue/cli4.x脚手架使用",
    "url": "/posts/Vue-Cli-Review/",
    "categories": "vue, vue-cli",
    "tags": "vue, javascript",
    "date": "2021-12-20 09:25:20 +0800",
    





    "snippet": "脚手架基础知识安装及创建项目vue cli官方文档 讲的很清楚项目结构目录结构├── public│   └── index.html├── src|   ├── main.js				# 项目的初始化|   ├── App.vue				# 项目的入口组件|	├── assest			 	# 项目中展示的图片或者全局样式|	│   ├── css|	│   ├── img|	│   └── ...|	├── api|	│   └── ... 			# 抽取出API请求|	├── components|	│   └── ...				# 项目中可复用的组件|	├── view				# ..."
  },
  
  {
    "title": "vue2.x基本概念",
    "url": "/posts/Vue-Basic/",
    "categories": "vue, vue-2x-basic",
    "tags": "vue, javascript",
    "date": "2021-11-20 16:25:20 +0800",
    





    "snippet": "简介官网介绍Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。  个人观点：（刚刚从React过来）  区别：            react在每更新一个组件之后，都会以这个组件为根，向上或向下将整个组件树都更新一遍。如果不需要，则需要手动配置shouldComponentUpadate。      而vue非常明确..."
  },
  
  {
    "title": "系统分析与设计--建立需求模型",
    "url": "/posts/SoftwareEngineer/",
    "categories": "software-engineer, system-analysis-and-design",
    "tags": "",
    "date": "2021-11-09 00:16:09 +0800",
    





    "snippet": "需求模型事件分类  外部事件          发生在系统之外      由外部的代理人或参与者所启动        临时事件（定时事件）          在到达某个时间点之后，自动发生的事件      根据系统的截止日期        状态事件          系统内部发生的某件事触发处理的需要      事件列表            事件      触发      来源      用例      回应      目的地                  一个完整的句子      动词      名词      动名词短语      形容词加名词      名词         ..."
  },
  
  {
    "title": "React基本概念",
    "url": "/posts/React-Basic/",
    "categories": "react, react-basic-es6",
    "tags": "react, javascript, JSX",
    "date": "2021-11-07 22:54:16 +0800",
    





    "snippet": "React 概述什么是ReactReact 是一个用于 构建用户界面 的  JavaScript 库。React的特点  组件化编程：某一个页面的任何一个部分都可以是一个组件。  用法很广泛：web、VR。。。React基本使用安装安装命令：npm i react react-dom  react包提供创建元素、组件等功能。  react-dom包提供DOM相关操作。使用      引入cdn    &amp;lt;script src=&quot;./node_modules/react/umd/react.deelopment.js&quot;&amp;gt;&amp;lt;/scr..."
  },
  
  {
    "title": "React Axios(请求)",
    "url": "/posts/React-Axios/",
    "categories": "react, react-Advanced-Component",
    "tags": "react, react-axios",
    "date": "2021-10-15 10:22:00 +0800",
    





    "snippet": "React-Axios基本使用Axios 安装      进入之前创建的脚手架app中执行以下两个命令中的其中一个    $ npm install react-axios$ yarn add axios      Axios Get请求//为给定 ID 的 User 创建请求axios.get(	&#39;url&#39;,    paras:{    	para1: value1,    	...    }).then((res) =&amp;gt; {    //成功后执行此处代码块  	console.log(res);}).catch((err) =&amp;gt; {    ..."
  },
  
  {
    "title": "React Router(路由)",
    "url": "/posts/React-Router/",
    "categories": "react, react-Advanced-Component",
    "tags": "react, react-router",
    "date": "2021-10-12 23:28:00 +0800",
    





    "snippet": "简介官方简介  React Router 是一个基于 React 之上的强大路由库，它可以让你向应用中快速地添加视图和数据流，同时保持页面与 URL 间的同步。个人理解  也就是将这个”网页”/”网站”，变得更加组件化，使元素树结构更加直观。安装      以下二选一    $ npm install --save react-router-dom$ yarn add react-router-dom      内置包import { Link, NavLink, Switch, Route, BrowserRouter } from &#39;react-router-dom&#39;..."
  },
  
  {
    "title": "SQL基础——视图、索引、事务",
    "url": "/posts/SQL-view/",
    "categories": "sql, sql-statement",
    "tags": "sql",
    "date": "2021-10-11 16:33:00 +0800",
    





    "snippet": "视图(view)作用  控制数据访问  简化查询  数据独立性  避免重复访问相同的数据视图的创建注意在运维数据库，对一些数据进行操作时，最好先将要操作的数据备份，然后再操作数据或者直接操作备份后的数据。-- 快速复制表结构，如果复制的表有数据，则顺势复制表中的所有数据。create table emp_bank	as 	select * from emp创建方法-- `create or replace` 表示如果创建的视图已存在则替换create or replace view v_emp_bank	as select ename, sal 		from emp_bank创建之后可以..."
  },
  
  {
    "title": "SQL基础——主键设计",
    "url": "/posts/SQL-rownum-pk/",
    "categories": "sql, sql-statement",
    "tags": "sql",
    "date": "2021-10-11 11:28:00 +0800",
    





    "snippet": "主键设计ROWNUM 和 ROWID（Oracle特有）ROWID特点：唯一，且固定，是在行数据生成时产生的id；select rowid, empno from emp;-- 此时的查询结果中，所有行的rowid字段是唯一的select rowid, empno from emp where empno = 7369;-- 该结果中-- empno=7369的rowid 和 -- 上一条 select 语句结果中empno=7369的rowid 相同  ROWID是永远不变的， 永远跟行记录走，不因查询条件而变化ROWNUM特点：一个伪列，对查询结果返回的行编号即行号，由1开始 依次递..."
  },
  
  {
    "title": "SQL练习——子查询",
    "url": "/posts/SQL-ChildQuery/",
    "categories": "sql, sql-statement",
    "tags": "sql",
    "date": "2021-10-09 23:00:00 +0800",
    





    "snippet": "子查询分为 关联子查询 和 非关联子查询特点：子查询可以单独执行，其结果作为外部查询的条件。不相关子查询概念：子查询不需要与父查询的结果进行比对-- 查询各个部门薪水最高的员工信息select * from emp	where (deptno, sal) in	(    	select deptno, max(sal) from emp group by deptno    )-- 哪些部门没有员工select * from dept	where deptno not in	(    	select deptno from emp group by deptno    )  整个过程中，..."
  },
  
  {
    "title": "SQL基础——约束",
    "url": "/posts/SQL-key/",
    "categories": "sql, sql-statement",
    "tags": "sql",
    "date": "2021-09-20 16:30:42 +0800",
    





    "snippet": "      主键：primary key（PK）—— unique + not null    外键：foreign key （FK）    唯一：unique    非空：not null    检查：check  一些术语DDL操作createcreate table student(    id number primary key,    name varchar2(20),    email char(40),    registtime date default sysdate);DML操作insert:      普通插入    insert into student(id..."
  },
  
  {
    "title": "SQL练习——多表查询",
    "url": "/posts/SQL-UnSingleTableQuery/",
    "categories": "sql, sql-statement",
    "tags": "sql",
    "date": "2021-09-13 21:43:00 +0800",
    





    "snippet": "多表查交叉连接  cross join  一般不用（因为无用信息太多）select * from emp cross join dept -- 依次从m行的emp中取一行emp，和n行dept中的每一行进行组合，也就是会产生一个nxm行的表格-- 根据以上结合的结果，如何查找到Smith的人所在的部门名称select emp.ename, dept.deptno, dept.dname from emp 	cross join dept where emp.deptno = dept.deptno and emp.ename = &#39;SMITH&#39;;缺点：  直接叉乘，得到的..."
  },
  
  {
    "title": "SQL练习——单表查询",
    "url": "/posts/SQL-SingleTableQuery/",
    "categories": "sql, sql-statement",
    "tags": "sql",
    "date": "2021-09-13 18:30:20 +0800",
    





    "snippet": "单表查询列的选取-投影select empno, ename, deptno from emp;  开发中一般不使用 *  数据库中：列名大小写不敏感，内容大小写敏感列别名      方法1：列名+” “+别名        方法2：列名 as 别名    select empno 员工编号, ename 员工姓名 from emp;select empno as 员工编号, ename as 员工姓名 from emp;      列的算数表达式(+,-,*,/)-- 显示年收入select empno, ename, sal*12 年收入 from emp;      处理空值得函数..."
  },
  
  {
    "title": "github-webhook与企业WeChat-webhook中间件开发(一)webhook",
    "url": "/posts/flask-python-webhock/",
    "categories": "python, flask",
    "tags": "python, flask, linux",
    "date": "2021-08-16 11:20:23 +0800",
    





    "snippet": "github-webhook与企业WeChat-robort中间件开发WebHook什么是WebHook最典型的例子：当你发送一条朋友圈，微信的服务器会把你的这条朋友圈同步到你所有好友的客户端（要是你屏蔽人了就是给服务器列出了特别名单）这还是 客户端 - 服务器 模式的逆转模式传统方法中，一般是客户端向服务器发出 请求 ，服务器给予客户端 响应 （这叫客户机拉取请求）在 WebHook 范式下，服务器更新所需提供的资源，然后自动将其作为更新发送到客户端（服务器是在推数据），客户端不是请求者，而是被动接收方应用场景对于第三方平台验权、登陆等 没有前端界面做中转的场景，或者强安全要求的支付场..."
  },
  
  {
    "title": "gitpage+jekyll搭建博客",
    "url": "/posts/blog-git-Jekyll/",
    "categories": "buildblog, build_step",
    "tags": "",
    "date": "2021-07-20 19:14:16 +0800",
    





    "snippet": "githubPage+Jekyll 搭建博客代码托管注册账号不用多说吧创建仓库点击右上角➕，再点击New repository仓库名的格式为 “用户名”.github.io（因为GitHub对于同一个账户只允许生成一个直接访问的网站）将仓库与本地连接（绑定）下载并安装git​    下载链接打开git-bash将git与仓库绑定git config --global user.name &quot;github用户名&quot;git config --global user.email &quot;邮箱&quot;SSH设置(github根据ssh接受你从本地对于git的管理)配置SS..."
  },
  
  {
    "title": "HashMap(一)用法",
    "url": "/posts/java-hashmap/",
    "categories": "java, Algorithm",
    "tags": "java, hashmap",
    "date": "2021-07-17 16:16:01 +0800",
    





    "snippet": "Java-HashMapHashMap（哈希表）的理解      其增删改查 在不考虑“哈希冲突时的时间复杂度仅有O(1)        主干是 数组 ，也就是通过某个”下标”即索引从而实现一次定位        哈希冲突 是指：虽然两个元素的 key 不同，但是他们的实际地址 却相同，即冲突  HashMap的使用      创建一个HashMap    Map&amp;lt;Key,Value&amp;gt; map = new HashMap&amp;lt;&amp;gt;();        这里的接口类型为Map，可以使程序更加灵活。当决定更换实现的时候，只需要改变构造器中类型..."
  }
  
]

